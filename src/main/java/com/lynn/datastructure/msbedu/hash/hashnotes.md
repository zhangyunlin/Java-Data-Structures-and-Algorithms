### 1. hash features
- 1. 输入域无穷，输出域有限。MD5 0-(2^64)-1, SHA1 0-(2^128)-1 hash函数的输出域有限。
- 2. same input, same output. 算法稳定。
- 3. diff in -> same out. hash collision.
- 4. hash follow a uniform distribution.

### 2.HashTable
- 如果要将N个数据存入HashTable,扩容的次数为O(logN)水平。
- 如果允许每个bucket下链表长度为k，则为O(logkN)水平，如果K足够大，则扩容次数趋近于O(1).
- 另外，JVM可以提供offline扩容技术，可以在hashtable不使用的时候，在内存不同区域中实现扩容。
所以hashtable实际的时间复杂度为O(logN),使用的时候配合JVM可以达到O(1)。

### 3.bloom filter
应用场景：
我有一个100亿个url组成的大文件，这些url都是黑名单，不能访问。每个url 64Byte。
用户访问的时候，需要判断用户url是否合法，能否访问。
【思路1】用HashSet存储，占用内存640G,太多。
【思路2】使用bloom filter，允许一定的失误率，就是有些访问被错误地拦截。
另外，网络公司的爬虫，如果有1000个threads,不希望重复爬取数据，就需要将爬取的链接记录下来，
这个链接url会非常多。

#### BitMap
本质就是bit[]，每个位置为一个bit。
用基础数据类型拼凑出BitMap。
int[] arr = new int[10]; //32bit * 10 = 320bit，可以表示长度为320的bit数组
//arr[0] 表示0-31位的信息
//arr[1] 表示32-63位的信息

int i = 187; //如何取得178个bit的信息？

int numIndex = 178 / 32; // 178 ÷ 32 = 5，说明第178位在 arr[5] 这个 int 里
int bitIndex = 178 % 32; // 178 % 32 = 18，说明在 arr[5] 的第18个 bit 上

//取得178位的状态0 or 1
int s =(arr[numIndex] >> bitIndex) & 1

//将178位改为1
arr[numIndex] = arr[numIndex] | (1 << bitIndex);

//将178位改为0
arr[numIndex] = arr[numIndex] & (~(1 << bitIndex));

//取出178位的信息
int bit = (arr[i/32]) >> (i % 32)) & 1;

### 一致性Hash
分布式系统，数据库分区，可以通过数据的key来做hash % m, 来确定数据进入哪一台数据库。
选择key的时候保证种类丰富，保证hash之后的值能够均匀分布。
eg： 选择性别，hash值只有两个，这个就不好。
并且，如果增加数据库服务器，数据会全量迁移，成本非常高。】

如何解决数据库服务器扩容的时候，不进行数据库迁移呢？这里就需要一致性hash。
1.将系统已有的的机器信息（mac地址，IP，其他不变的特征信息）进行hash，得到每台机器的hash值；
2.将机器的hash值分布在一个环形数组上。
3.数据计算hash值，将数据打到环上，将数据存储到顺时针最近的一台服务器上。
4.将有机器加入的时候，只需要将之前顺时针段数据迁移过来就行。
【问题】
1. 机器数量很少的时候，不会在环上均匀分布，导致有些机器存储数据多，有些少；
2. 机器增加或者减少的时候，各个机器负载的圆弧长度不同，负载不均衡。
【解决】虚拟节点技术
1. A，B，C机器分配1000个string,每个字符串hash，将hash位分列在bit环上，
这样能够保证归属于ABC机器的节点接近均匀分布，达到负载均衡。
2. 加入服务器节点的时候，也分配1000个hash节点，完成负载分配和数据迁移；
3. 对于配置高的节点，可以分配2000个hash节点，对于配置低的节点，分配500个节点，达到资源有效利用。



